Git workflow:
--------------------------------------------------------------------------------------------------
cd vc-git/git-workplace/thesis
nano thesis.txt // write changes - ctrl + x > y > enter to save and exit
git add thesis.txt
git commit thesis.txt -m "Write message"

git status
git log --oneline //Shows logs on one line
git diff --staged //see changes between commits

rm .git/index.lock //terminating git process
git diff HEAD~1 thesis.txt //show changes in commit
git show HEAD~2 thesis.txt //show changes made 2 commits ago

git checkout <hash or HEAD~1> thesis.txt //recovers old version of the file 

//To get data from the online repository
git remote add origin https://github.com/lm2292/Inomech_Roboty.git
git branch -M main
git push -u origin main

git pull
git push

rm -rf .git

Git key points: 
--------------------------------------------------------------------------------------------------

Setup
-------------------------------------------------
Jupyter notebooks are a really useful platform for exploring code and sharing reproducible research
We use them because they are a convenient platform for delivery training and have a Linux terminal
The University runs the ‘linux.bath’ service to provide a general use Linux machine
‘linux.bath’ provides certain academic software for students and staff
The service is a shared machine designed for lightweight use
For heavy workloads you should investigate using the Unviersity’s HPC service

Automated Version Control
-------------------------------------------------
Version control is like an unlimited ‘undo’.
Version control also allows many people to work in parallel.

Setting up git
-------------------------------------------------
Use git config to configure a user name, email address, editor, and other preferences once per machine.

Creating a repository
-------------------------------------------------
git init initializes a repository.
Keep gits separate

Tracking changes
-------------------------------------------------
git status shows the status of a repository.
Files can be stored in a project’s working directory (which users see), the staging area (where the next 
commit is being built up) and the local repository (where commits are permanently recorded).
git add puts files in the staging area.
git commit saves the staged content as a new commit in the local repository.
Always write a log message when committing changes.
Use git log to check the history of the repository

Exploring history
-------------------------------------------------
git diff displays differences between commits.
git checkout <commit id> <file> recovers old versions of files.

Changing history
-------------------------------------------------
git mv can be used to rename or move files within the repository.
git rm can be used to remove a file from a repository, or with --cached unstage a file
git checkout <commit id> <file> recovers old versions of files.
git checkout <commit id> moves your position in the repository.
git revert can be used to revert the entire repository to a previous state, or undo changes in range of commits, 
creating a new commit.
git reset changes the current HEAD to an earlier commit

Ignoring things
-------------------------------------------------
The .gitignore file tells Git what files to ignore.

Remotes in Github
-------------------------------------------------
A local Git repository can be connected to one or more remote repositories.
Use the HTTPS protocol to connect to remote repositories until you have learned how to set up SSH.
git push copies changes from a local repository to a remote repository.
git pull copies changes from a remote repository to a local repository.

Collaborating
-------------------------------------------------
git clone copies a remote repository to create a local repository with a remote called origin automatically set 
up.
git pull updates your local copy of the repository with any changes to the remote.
git fetch fetches changes to the remote allowing you to compare them without merging

Conflicts
-------------------------------------------------
Conflicts occur when two or more people change the same file(s) at the same time.
The version control system does not allow people to overwrite each other’s changes blindly, but highlights 
conflicts so that they can be resolved.

Open science
-------------------------------------------------
Open scientific work is more useful and more highly cited than closed.



///
/// Below is a more detailed talk about the individual topics from key points above
///


Setting up git
--------------------------------------------------------------------------------------------------

How do I get set up to use Git?
Objectives

Configure git the first time it is used on a computer.
Understand the meaning of the --global configuration flag.
First you will need to launch a terminal, e.g. see setup. For the purposes of this lesson, if you are running on 
notebooks.azure.com we will work in the library folder, so before doing anything else we need to change directory:

% cd library

If you using git on another platform then this is not necessary.

Configure your git
------------------------
When we use Git on a new computer for the first time, we need to configure a few things. Below are a few 
examples of configurations we will set as we get started with Git:

our name and email address,
to colorize our output,
what our preferred text editor is,
and that we want to use these settings globally (i.e. for every project)
On a command line, Git commands are written as git verb, where verb is what we actually want to do. So here is 
how Dracula sets up his new laptop:

% git config --global user.name "Vlad Dracula"
% git config --global user.email "vlad@tran.sylvan.ia"
% git config --global color.ui "auto"

Please use your own name and email address instead of Dracula’s. This user name and email will be 
associated with your subsequent Git activity, which means that any changes pushed to GitHub, BitBucket, GitLab or another Git host server in a later lesson will include this information.

 Line Endings
------------------------
As with other keys, when you hit the ‘return’ key on your keyboard, your computer encodes this input. 
For reasons that are long to explain, different operating systems use different character(s) to represent 
the end of a line. (You may also hear these referred to as newlines or line breaks.) Because git uses these 
characters to compare files, it may cause unexpected issues when editing a file on different machines.

You can change the way git recognizes and encodes line endings using the core.autocrlf command to git config. 
The following settings are recommended:

On OS X and Linux:

% git config --global core.autocrlf input

And on Windows:

% git config --global core.autocrlf true

You can read more about this issue on this GitHub page.

For these lessons, we will be interacting with GitHub and so the email address used should be the same as 
the one used when setting up your GitHub account. If you are concerned about privacy, please review GitHub’s 
instructions for keeping your email address private. If you elect to use a private email address with GitHub, 
then use that same email address for the user.email value, e.g. username@users.noreply.github.com replacing 
username with your GitHub one. You can change the email address later on by using the git config command again.

Dracula also has to set his favorite text editor, following this table:

Editor	Configuration command
Atom	% git config --global core.editor "atom --wait"
nano	% git config --global core.editor "nano -w"
BBEdit (Mac, with command line tools)	% git config --global core.editor "bbedit -w"
Sublime Text (Mac)	% git config --global core.editor "subl -n -w"
Sublime Text (Win, 32-bit install)	% git config --global core.editor "'c:/program files (x86)/sublime text 3/sublime_text.exe' -w"
Sublime Text (Win, 64-bit install)	% git config --global core.editor "'c:/program files/sublime text 3/sublime_text.exe' -w"
Notepad++ (Win, 32-bit install)	% git config --global core.editor "'c:/program files (x86)/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin"
Notepad++ (Win, 64-bit install)	% git config --global core.editor "'c:/program files/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin"
Kate (Linux)	% git config --global core.editor "kate"
Gedit (Linux)	% git config --global core.editor "gedit --wait --new-window"
Scratch (Linux)	% git config --global core.editor "scratch-text-editor"
emacs	% git config --global core.editor "emacs"
vim	% git config --global core.editor "vim"
It is possible to reconfigure the text editor for Git whenever you want to change it.

The four commands we just ran above only need to be run once: the flag --global tells Git to use the settings for 
every project, in your user account, on this computer.

You can check your settings at any time:

%%bash2 --dir ~
git config --list
user.name=James Grant
user.email=r.j.grant@bath.ac.uk
merge.tool=kdiff3
diff.guitool=kdiff3
core.editor=nano -w
core.autocrlf=true
color.ui=auto

Git Help and Manual
------------------------
Always remember that if you forget a git command, you can access the list of commands by using -h and access the 
Git manual by using --help:

% git config -h
% git config --help

Additionally online manual pages or Stack Overflow are excellent resources.

Key Points
------------------------
Use git config to configure a user name, email address, editor, and other preferences once per machine.










Creating a Repository
--------------------------------------------------------------------------------------------------

Where does Git store information?
Objectives

Create a local Git repository.
------------------------
Once Git is configured, we can start using it. Let’s create a directory for our work and then move into that 
directory:

% mkdir planets
% cd planets

Then we tell Git to make planets a repository—a place where Git can store versions of our files:

% git init

If we use ls to show the directory’s contents, it appears that nothing has changed:

% ls

Initialising our repository apparently did nothing, but if we add the -a flag to show everything, we can see that 
Git has created a hidden directory within planets called .git:

% ls -a
.   ..  .git

Git stores information about the project in this special sub-directory. If we ever delete it, we will lose the 
project’s history.

We can check that everything is set up correctly by asking Git to tell us the status of our project:

% git status

# On branch master
#
# Initial commit
#
nothing to commit (create/copy files and use "git add" to track)

If you are using a different version of git than I am, then the exact wording of the output might be slightly 
different.

When and where to create git repositories
------------------------
Dracula starts a new project, moons, related to his planets project. Despite Wolfman’s concerns, he enters the 
following sequence of commands to create one Git repository inside another:

% cd             # return to home directory
% mkdir planets  # make a new directory planets
% cd planets     # go into planets
% git init       # make the planets directory a Git repository
% mkdir moons    # make a sub-directory planets/moons
% cd moons       # go into planets/moons
% git init       # make the moons sub-directory a Git repository
Why is it a bad idea to do this?

Keep repositories separate
------------------------
Notice here that the planets project is now also tracking the entire moons repository.

Git repositories can interfere with each other if they are “nested” in the directory of another: the outer 
repository will try to version-control the inner repository. Therefore, it’s best to create each new Git repository 
in a separate directory. To be sure that there is no conflicting repository in the directory, check the output of 
git status. If it looks like the following, you are good to go to create a new repository as shown above:

% git status
fatal: Not a git repository (or any of the parent directories): .git
To recover from this little mistake, Dracula can just remove the .git folder in the moons subdirectory. To do so 
he can run the following command from inside the ‘moons’ directory:

% rm -rf moons/.git
But be careful! Running this command in the wrong directory, will remove the entire git-history of a project you
 might wanted to keep. Therefore, always check your current directory using the command pwd.

Key Points
------------------------
git init initializes a repository.
Keep gits separate








Tracking Changes
--------------------------------------------------------------------------------------------------

How do I record changes in Git?
How do I check the status of my version control repository?
How do I record notes about what changes I made and why?
Objectives

Go through the modify-add-commit cycle for one or more files.
Explain where information is stored at each stage of that cycle.
Distinguish between descriptive and non-descriptive commit messages.
First let’s make sure we’re still in the right directory. You should be in the planets directory.

% pwd

If you are still in moons navigate back up to planets:

% cd ..

Let’s create a file called mars.txt that contains some notes about the Red Planet’s suitability as a base. 
We’ll use nano to edit the file; you can use whatever editor you like. In particular, this does not have to be 
the core.editor you set globally earlier. But remember, the bash command to create or edit a new file will depend 
on the editor you choose (it might not be nano).

% nano mars.txt

Type the text below into the mars.txt file:

Cold and dry, but everything is my favorite color
Save and exit nano. We have created mars.txt which we can see by running:

% ls
mars.txt

and check its contents with:

% cat mars.txt

Cold and dry, but everything is my favorite color
If we check the status of our project again, Git tells us that it’s noticed the new file:

% git status

On branch master

Initial commit

Untracked files:
   (use "git add <file>..." to include in what will be committed)

    mars.txt

nothing added to commit but untracked files present (use "git add" to track)
The “untracked files” message means that there’s a file in the directory that Git isn’t keeping track of. 
We can tell Git to track a file using git add:

% git add mars.txt

On branch master

Initial commit

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)

    new file:   mars.txt

Git now knows that it’s supposed to keep track of mars.txt, but it hasn’t recorded these changes as a commit yet. 
To get it to do that, we need to run one more command:

% git commit -m "Start notes on Mars as a base"
[master (root-commit) f22b25e] Start notes on Mars as a base
 1 file changed, 1 insertion(+)
 create mode 100644 mars.txt
When we run git commit, Git takes everything we have told it to save by using git add and stores a copy 
permanently inside the special .git directory. This permanent copy is called a commit (or revision) and its 
short identifier is f22b25e (Your commit will probably have another identifier.)

We use the -m flag (for “message”) to record a short, descriptive, and specific comment that will help us remember 
later on what we did and why. If we just run git commit without the -m option, Git will launch nano (or whatever 
other editor we configured as core.editor) so that we can write a longer message.

Good commit messages start with a brief (<50 characters) summary of changes made in the commit. If you want to 
go into more detail, add a blank line between the summary line and your additional notes.

If we run git status now:

git status
On branch master
nothing to commit, working directory clean
This tells us everything is up to date. If we want to know what we’ve done recently, we can ask Git to show us 
the project’s history using git log:

% git log
commit f22b25e3233b4645dabd0d81e651fe074bd8e73b
Author: Vlad Dracula <vlad@tran.sylvan.ia>
Date:   Thu Aug 22 09:51:46 2013 -0400

    Start notes on Mars as a base
git log lists all commits made to a repository in reverse chronological order. The listing for each commit 
includes the commit’s full identifier (which starts with the same characters as the short identifier printed 
by the git commit command earlier), the commit’s author, when it was created, and the log message Git was given 
when the commit was created.

Now suppose Dracula adds more information to the file. Again, we’ll edit with nano and then cat the file to 
show its contents. Run:

% nano mars.txt
and add the line:

The two moons may be a problem for Wolfman
save and exit, the check the contents with cat:

% cat mars.txt
Cold and dry, but everything is my favorite color
The two moons may be a problem for Wolfman
 Where are my changes?
If we run ls at this point, we will still see just one file called mars.txt. That’s because Git saves information 
about files’ history in the special .git directory mentioned earlier so that our filesystem doesn’t become 
cluttered (and so that we can’t accidentally edit or delete an old version).

When we run git status now, it tells us that a file it already knows about has been modified:

% git status
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   mars.txt

no changes added to commit (use "git add" and/or "git commit -a")
The last line is the key phrase: “no changes added to commit”. We have changed this file, but we haven’t told 
Git we will want to save those changes (which we do with git add) nor have we saved them (which we do with git 
commit). So let’s do that now. It is good practice to always review our changes before saving them. We do this 
using git diff. This shows us the differences between the current state of the file and the most recently saved 
version:

% git diff
diff --git a/mars.txt b/mars.txt
index df0654a..315bf3a 100644
--- a/mars.txt
+++ b/mars.txt
@@ -1 +1,2 @@
 Cold and dry, but everything is my favorite color
+The two moons may be a problem for Wolfman
The output is cryptic because it is actually a series of commands for tools like editors and patch telling them 
how to reconstruct one file given the other. If we break it down into pieces:

The first line tells us that Git is producing output similar to the Unix diff command comparing the old and new 
versions of the file. The second line tells exactly which versions of the file Git is comparing: df0654a and 
315bf3a are unique computer-generated labels for those versions. The third and fourth lines once again show the 
name of the file being changed. The remaining lines are the most interesting, they show us the actual differences 
and the lines on which they occur. In particular, the + marker in the first column shows where we added a line.

After reviewing our change, it’s time to commit it:

% git commit -m "Add concerns about effects of Mars' moons on Wolfman"
% git status
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   mars.txt

no changes added to commit (use "git add" and/or "git commit -a")
Whoops: Git won’t commit because we didn’t use git add first. Let’s fix that:

% git add mars.txt
% git commit -m "Add concerns about effects of Mars' moons on Wolfman"
[master 34961b1] Add concerns about effects of Mars' moons on Wolfman
 1 file changed, 1 insertion(+)
Git insists that we add files to the set we want to commit before actually committing anything. This allows us 
to commit our changes in stages and capture changes in logical portions rather than only large batches. For 
example, suppose we’re adding a few citations to relevant research to our thesis. We might want to commit those 
additions, and the corresponding bibliography entries, but not commit some of our work drafting the conclusion 
(which we haven’t finished yet).

To allow for this, Git has a special staging area where it keeps track of things that have been added to the 
current changeset but not yet committed.

 Staging Area
If you think of Git as taking snapshots of changes over the life of a project, git add specifies what will go in 
a snapshot (putting things in the staging area), and git commit then actually takes the snapshot, and makes a 
permanent record of it (as a commit). If you don’t have anything staged when you type git commit, Git will prompt 
you to use git commit -a or git commit --all, which is kind of like gathering everyone for the picture! However, 
it’s almost always better to explicitly add things to the staging area, because you might commit changes you forgot 
you made. (Going back to snapshots, you might get the extra with incomplete makeup walking on the stage for the 
snapshot because you used -a!) Try to stage things manually, or you might find yourself searching for “git undo 
commit” more than you would like!Stagig Area

Let’s watch as our changes to a file move from our editor to the staging area and into long-term storage. First, 
we’ll add another line to the file:

% nano mars.txt
% cat mars.txt
Cold and dry, but everything is my favorite color
The two moons may be a problem for Wolfman
But the Mummy will appreciate the lack of humidity
And confirm the change with git

% git diff
diff --git a/mars.txt b/mars.txt
index 315bf3a..b36abfd 100644
--- a/mars.txt
+++ b/mars.txt
@@ -1,2 +1,3 @@
 Cold and dry, but everything is my favorite color
 The two moons may be a problem for Wolfman
+But the Mummy will appreciate the lack of humidity
So far, so good: we’ve added one line to the end of the file (shown with a + in the first column). Now let’s put 
that change in the staging area and see what git diff reports:

% git add mars.txt
% git diff

There is no output: as far as Git can tell, there’s no difference between what it’s been asked to save permanently 
and what’s currently in the directory. However, if we do this:

% git diff --staged

diff --git a/mars.txt b/mars.txt
index 315bf3a..b36abfd 100644
--- a/mars.txt
+++ b/mars.txt
@@ -1,2 +1,3 @@

 Cold and dry, but everything is my favorite color
 The two moons may be a problem for Wolfman
+But the Mummy will appreciate the lack of humidity
This shows us the difference between the last committed change and what’s in the staging area. Let’s save our 
changes:

% git commit -m "Discuss concerns about Mars' climate for Mummy"

[master 005937f] Discuss concerns about Mars' climate for Mummy
 1 file changed, 1 insertion(+)
and check our status:

% git status

On branch master
nothing to commit, working directory clean
How can we look at the history of what we’ve done so far:

% git log

commit 005937fbe2a98fb83f0ade869025dc2636b4dad5
Author: Vlad Dracula <vlad@tran.sylvan.ia>
Date:   Thu Aug 22 10:14:07 2013 -0400

    Discuss concerns about Mars' climate for Mummy

commit 34961b159c27df3b475cfe4415d94a6d1fcd064d
Author: Vlad Dracula <vlad@tran.sylvan.ia>
Date:   Thu Aug 22 10:07:21 2013 -0400

    Add concerns about effects of Mars' moons on Wolfman

commit f22b25e3233b4645dabd0d81e651fe074bd8e73b
Author: Vlad Dracula <vlad@tran.sylvan.ia>
Date:   Thu Aug 22 09:51:46 2013 -0400

    Start notes on Mars as a base
 Word-based diffing
------------------------
Sometimes, e.g. in the case of the text documents a line-wise diff is too coarse. That is where the --color-words 
option of git diff comes in very useful as it highlights the changed words using colors.

 Paging the Log
------------------------
When the output of git log is too long to fit in your screen, git uses a program to split it into pages of the 
size of your screen. When this “pager” is called, you will notice that the last line in your screen is a :, 
instead of your usual prompt.

To get out of the pager, press q. To move to the next page, press the space bar. To search for some_word in all 
pages, type /some_word and navigate through matches pressing n.

 Limit Log Size
------------------------
To avoid having git log cover your entire terminal screen, you can limit the number of commits that Git lists by 
using -N, where N is the number of commits that you want to view. For example, if you only want information from 
the last commit you can use:

% git log -1
commit 005937fbe2a98fb83f0ade869025dc2636b4dad5
Author: Vlad Dracula <vlad@tran.sylvan.ia>
Date:   Thu Aug 22 10:14:07 2013 -0400

   Discuss concerns about Mars' climate for Mummy
You can also reduce the quantity of information using the --oneline option:

% git log --oneline
* 005937f Discuss concerns about Mars' climate for Mummy
* 34961b1 Add concerns about effects of Mars' moons on Wolfman
* f22b25e Start notes on Mars as a base
You can also combine the --oneline options with others. One useful combination is:

% git log --oneline --graph --all --decorate
As before git log -h provides a brief overview of usage, while more detailed help is found with man git log.

 Directories
------------------------
Two important facts you should know about directories in Git.

Git does not track directories on their own, only files within them. Try it for yourself:

% mkdir directory
% git status
% git add directory
% git status
Note, our newly created empty directory directory does not appear in the list of untracked files even if we 
explicitly add it (via git add) to our repository. This is the reason why you will sometimes see .gitkeep 
files in otherwise empty directories. Unlike .gitignore, these files are not special and their sole purpose is 
to populate a directory so that Git adds it to the repository. In fact, you can name such files anything you like.

If you create a directory in your Git repository and populate it with files, you can add all files in the 
directory at once by:

git add <directory-with-files>
To recap, when we want to add changes to our repository, we first need to add the changed files to the staging 
area (git add) and then commit the staged changes to the repository (git commit):

git committing

 Choosing a Commit Message
------------------------
Which of the following commit messages would be most appropriate for the last commit made to mars.txt?

“Changes”
“Added line ‘But the Mummy will appreciate the lack of humidity’ to mars.txt”
“Discuss effects of Mars’ climate on the Mummy”

Solution

 Committing Changes to Git
------------------------
Which command(s) below would save the changes of myfile.txt to my local Git repository?

% git commit -m "my recent changes"
% git init myfile.txt 
% git commit -m "my recent changes"
% git add myfile.txt 
% git commit -m "my recent changes"
% git commit -m myfile.txt "my recent changes"
Solution

 Committing Multiple Files
The staging area can hold changes from any number of files that you want to commit as a single snapshot.

Add some text to mars.txt noting your decision to consider Venus as a base
Create a new file venus.txt with your initial thoughts about Venus as a base for you and your friends
Add changes from both files to the staging area, and commit those changes.

Solution

 Author and Committer
For each of the commits you have done, Git stored your name twice. You are named as the author and as the 
committer. You can observe that by telling Git to show you more information about your last commits:

% git log --format=full
When committing you can name someone else as the author:

% git commit --author="Vlad Dracula <vlad@tran.sylvan.ia>"
Create a new repository and create two commits: one without the --author option and one by naming a colleague 
of yours as the author. Run git log and git log --format=full. Think about ways how that can allow you to 
collaborate with your colleagues.

Solution

 Key Points
git status shows the status of a repository.
Files can be stored in a project’s working directory (which users see), the staging area (where the next commit 
is being built up) and the local repository (where commits are permanently recorded).
git add puts files in the staging area.
git commit saves the staged content as a new commit in the local repository.
Always write a log message when committing changes.
Use git log to check the history of the repository









Exploring History
---------------------------------------------------------------------------------------------------

How can I identify old versions of files?
How do I review my changes?
How can I recover old versions of files?
Objectives

Explain what the HEAD of a repository is and how to use it.
Identify and use Git commit numbers.
Compare various versions of tracked files.
Restore old versions of files.
As we saw in the previous lesson, we can refer to commits by their identifiers. You can refer to the most 
recent commit of the working directory by using the identifier HEAD.

We’ve been adding one line at a time to mars.txt, so it’s easy to track our progress by looking, so let’s do 
that using our HEADs. Before we start, let’s make a change to mars.txt.

% nano mars.txt
% cat mars.txt
Cold and dry, but everything is my favorite color
The two moons may be a problem for Wolfman
But the Mummy will appreciate the lack of humidity
An ill-considered change
Now, let’s see what we get.

$ git diff HEAD mars.txt
diff --git a/mars.txt b/mars.txt
index b36abfd..0848c8d 100644
--- a/mars.txt
+++ b/mars.txt
@@ -1,3 +1,4 @@
 Cold and dry, but everything is my favorite color
 The two moons may be a problem for Wolfman
 But the Mummy will appreciate the lack of humidity
+An ill-considered change.
which is the same as what you would get if you leave out HEAD (try it). The real goodness in all this is when
 you can refer to previous commits. We do that by adding ~1 to refer to the commit one before HEAD.

If we want to see the differences between older commits we can use git diff again, but with the notation HEAD~1, 
HEAD~2, and so on, to refer to them:

$ git diff HEAD~1 mars.txt
$ git diff HEAD~2 mars.txt
We could also use git show which shows us what changes we made at an older commit as well as the commit message, 
rather than the differences between a commit and our working directory that we see by using git diff.

$ git show HEAD~2 mars.txt
commit 34961b159c27df3b475cfe4415d94a6d1fcd064d
Author: Vlad Dracula <vlad@tran.sylvan.ia>
Date:   Thu Aug 22 10:07:21 2013 -0400

    Start notes on Mars as a base
-------------------------------------------------
diff --git a/mars.txt b/mars.txt
new file mode 100644
index 0000000..df0654a
--- /dev/null
+++ b/mars.txt
@@ -0,0 +1 @@
+Cold and dry, but everything is my favorite color
In this way, we can build up a chain of commits. The most recent end of the chain is referred to as HEAD; we can 
refer to previous commits using the ~ notation, so HEAD~1 (pronounced “head minus one”) means “the previous commit”,
 while HEAD~123 goes back 123 commits from where we are now.

We can also refer to commits using those long strings of digits and letters that git log displays. These are unique 
IDs for the changes, and “unique” really does mean unique: every change to any set of files on any computer has a 
unique 40-character identifier. Our first commit was given the ID f22b25e3233b4645dabd0d81e651fe074bd8e73b, so 
let’s try this:

$ git diff f22b25e3233b4645dabd0d81e651fe074bd8e73b mars.txt
diff --git a/mars.txt b/mars.txt
index df0654a..93a3e13 100644
--- a/mars.txt
+++ b/mars.txt
@@ -1 +1,4 @@
 Cold and dry, but everything is my favorite color
+The two moons may be a problem for Wolfman
+But the Mummy will appreciate the lack of humidity
+An ill-considered change
All right! So we can save changes to files and see what we’ve changednow how can we restore older versions of 
things? Let’s suppose we accidentally overwrite our file:

% nano mars.txt
% cat mars.txt
We will need to manufacture our own oxygen
git status now tells us that the file has been changed, but those changes haven’t been staged:

$ git status
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   mars.txt

no changes added to commit (use "git add" and/or "git commit -a")
We can put things back the way they were by using git checkout:

$ git checkout HEAD mars.txt
$ cat mars.txt
Cold and dry, but everything is my favorite color
The two moons may be a problem for Wolfman
But the Mummy will appreciate the lack of humidity
As you might guess from its name, git checkout checks out (i.e., restores) an old version of a file. In this case,
 we’re telling Git that we want to recover the version of the file recorded in HEAD, which is the last saved commit.
 If we want to go back even further, we can use a commit identifier instead:

% git checkout f22b25e mars.txt
% cat mars.txt
Cold and dry, but everything is my favorite color
$ git status
# On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)
# Changes not staged for commit:
#   (use "git add <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
#   modified:   mars.txt
#
no changes added to commit (use "git add" and/or "git commit -a")
Notice that the changes are on the staged area. Again, we can put things back the way they were by using git 
checkout:

% git checkout HEAD mars.txt
 Don’t Lose Your HEAD
Above we used

% git checkout f22b25e mars.txt
to revert mars.txt to its state after the commit f22b25e. If you forget mars.txt in that command, Git will tell 
you that “You are in ‘detached HEAD’ state.” In this state, you shouldn’t make any changes. You can fix this by 
reattaching your head using git checkout master

It’s important to remember that we must use the commit number that identifies the state of the repository before 
the change we’re trying to undo. A common mistake is to use the number of the commit in which we made the change 
we’re trying to get rid of. In the example below, we want to retrieve the state from before the most recent commit 
(HEAD~1), which is commit f22b25e:Git chekcoutSo, to put it all together, here’s how Git works in cartoon form:Git 
staging

 Simplifying the Common Case
-------------------------------------------------
If you read the output of git status carefully, you’ll see that it includes this hint:

(use "git checkout -- <file>..." to discard changes in working directory)
As it says, git checkout without a version identifier restores files to the state saved in HEAD. The double dash 
-- is needed to separate the names of the files being recovered from the command itself: without it, Git would try
to use the name of the file as the commit identifier.

The fact that files can be reverted one by one tends to change the way people organize their work. If everything 
is in one large document, it’s hard (but not impossible) to undo changes to the introduction without also undoing 
changes made later to the conclusion. If the introduction and conclusion are stored in separate files, on the other
 hand, moving backward and forward in time becomes much easier.


 Recovering Older Versions of a File
-------------------------------------------------
Jennifer has made changes to the Python script that she has been working on for weeks, and the modifications she 
made this morning “broke” the script and it no longer runs. She has spent ~ 1hr trying to fix it, with no luck…


Luckily, she has been keeping track of her project’s versions using Git! Which commands below will let her recover 
the last committed version of her Python script called data_cruncher.py?

% git checkout HEAD`
% git checkout HEAD data_cruncher.py`
% git checkout HEAD~1 data_cruncher.py`
% git checkout <unique ID of last commit> data_cruncher.py`
Both 2 and 4
 Checking Understanding of git diff
Consider this command: git diff HEAD~3 mars.txt. What do you predict this command will do if you execute it? What
 happens when you do execute it? Why?

Try another command, git diff [ID] mars.txt, where [ID] is replaced with the unique identifier for your most recent
 commit. What do you think will happen, and what does happen?

 Getting Rid of Staged Changes
git checkout can be used to restore a previous commit when unstaged changes have been made, but will it also work 
for changes that have been staged but not committed? Make a change to mars.txt, add that change, and use git checkout to see if you can remove your change.

 Explore and Summarize Histories
Exploring history is an important part of git, often it is a challenge to find the right commit ID, especially if the commit is from several months ago.


Imagine the planets project has more than 50 files. You would like to find a commit with specific text in mars.txt 
is modified. When you type git log, a very long list appeared, How can you narrow down the search?

Recall that the git diff command allow us to explore one specific file, e.g. git diff mars.txt. We can apply a
 similar idea here.

% git log mars.txt
Unfortunately some of these commit messages are very ambiguous e.g. update files. How can you search through these 
files?

Both git diff and git log are very useful and they summarize a different part of the history for you. Is it 
possible to combine both? Let’s try the following:

% git log --patch mars.txt
You should get a long list of output, and you should be able to see both commit messages and the difference 
between each commit.

Question: What does the following command do?

% git log --patch HEAD~3 *.txt
While we all try to provide useful commit messages git provides the tools to help use understand even our least
 nformative commit messages, through the combination of specific commit ids and files.

 Key Points
git diff displays differences between commits.
git checkout <commit id> <file> recovers old versions of files.











Changing History
---------------------------------------------------------------------------------------------------

How should I change filenames in git
How do I remove files in Git
What does checkout do?
What are revert and reset?
Objectives

Know how to rename and remove git tracked files.
Understand that checkout moves you around in the git history.
Know that revert and reset move and remove commits respectively, they change history around you.
Know how to undo staging of files.
Changing a filename
Let's say that we would like to create a duplicate of mars.txt e.g. so that so that Wolfman could record his own observation separately from Vlad. Create a copy of mars.txt with:

% cp mars.txt mars2.txt
% ls

mars.txt  mars2.txt
and add the file and commit it to the repository:

% git add mars2.txt
% git commit -m "Duplicated mars.txt for Wolfman's observations"

[master 096d729] Duplicated mars.txt for Wolfman's observations
 1 file changed, 3 insertions(+)
 create mode 100644 mars2.txt
Later we realise that this isn't the most informative filename so decide to change the filename to `mars_wolfman.txt":

% mv mars2.txt mars_wolfman.txt
We can now check the status of the repository:

% git status

On branch master
Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        deleted:    mars2.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        mars_wolfman.txt

no changes added to commit (use "git add" and/or "git commit -a")
We could now add the new file and while this is in principle okay, in that it will result in the file 
changing name, it is inefficient for git to delete and create with the same content. However there is 
another git like way. First lets revert the filename:

% mv mars_wolfman.txt mars2.txt
% git status
On branch master
nothing to commit, working tree clean
Now we use the command:

% git mv mars2.txt mars_wolfman.txt
% git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        renamed:    mars2.txt -> mars_wolfman
Note that these changes are staged we still have to commit the change, but we no longer have to git add 
the new filename. Let's commit the change of filename:

% git commit -m "Changed filename for Wolfmans observations"
[master 2d64b0a] Changed filename for Wolfmans observations
 1 file changed, 0 insertions(+), 0 deletions(-)
 rename mars2.txt => mars_wolfman.txt (100%)
Finally we learn that we will learn about how to deal with potential conflicts between commits in a future 
episode so decide to delete the new file. Once again we could just remove the file with rm but suspect that 
as with changing filenames there might be a git way of removing files. Indeed there is and we can remove the 
file from the repository with the command:

% git rm mars_wolfman.txt
% git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        deleted:    mars_wolfman.txt
As always these changes are staged and we need to commit them to the repository:

% git commit -m "Deleted unnecessary wolfman duplicate file"
[master 67edf4e] Deleted unnecessary wolfman duplicate file
 1 file changed, 3 deletions(-)
 delete mode 100644 mars_wolfman.txt
Checkout, Revert and Reset
In the previous episode we used the command git checkout HEAD <file>, to undo changes to a file that we wanted 
to discard. Used in this was checkout switches to the version of the file in the specified commit. We can also 
use checkout without specifying a filename, to move to a different position in the git history, as seen in the 
previous episode under "Don’t Lose Your HEAD".

What happens if we want to undo some changes we have made in error but keep a record of them instead of moving 
around in the history. Perhaps we don't believe our instructor that it is possible to deal with conflicts and we 
want to revert to the previous commit before mars_wolfman.txt was deleted. We could try running git checkout 
HEAD~1 mars_wolfman.txt but if we had removed or changed several files then this would take a while and we might 
forget to checkout out one of the files.

Fortunately git offers us a quick way to do this with the command, and check the review the git log for the last 
two commits:

% git revert HEAD # Note we want to revert the last commit
% git log -2
commit f8e774dab9bc05cf72d92df90297d0dd352f2fcd (HEAD -> master)
Author: James Grant <r.j.grant@bath.ac.uk>
Date:   Fri Nov 9 14:56:34 2018 +0000

    Revert "Deleted unnecessary wolfman duplicate file"

    This reverts commit 67edf4e4268580162931e994d0e960ac11d44bcb.

commit 67edf4e4268580162931e994d0e960ac11d44bcb
Author: James Grant <r.j.grant@bath.ac.uk>
Date:   Fri Nov 9 14:28:28 2018 +0000

    Deleted unnecessary wolfman duplicate file
-------------------------------------------------
After speaking with your collaborator you decide to bare with your instructor for the rest of the workshop and 
want to undo the changes you've made to avoid embarassment. This is of course unnecessary as we are all here 
learning together, but perhaps we want to tidy the repository a bit. We can remove any record of what we've been
 doing with the reset command.

First lets check theoneline version of the log:
-------------------------------------------------

% git log --oneline
f8e774d (HEAD -> master) Revert "Deleted unnecesssary duplicate"
67edf4e Deleted unnecesssary duplicate
2d64b0a Changed file2.txt name
096d729 duplicated
a5fb509 Discuss concerns about Mars' climate for Mummy
70244e4 Add concerns about effects of Mars' moons on Wolfman
d0aac91 Start notes on Mars as a base
We want to go back to the commit before we duplicated the file, when we "Discuss concerns about Mars' climate 
for Mummy", i.e. remove everything we've done in this episode from the repository. We can do this with the 
command git reset


% git reset a5fb509
% git status
% git log --online
a5fb509 Discuss concerns about Mars' climate for Mummy
70244e4 Add concerns about effects of Mars' moons on Wolfman
d0aac91 Start notes on Mars as a base
Note that git reset has (apparently) deleted all commits after the one we have chosen to reset to. This is 
different from revert which changed the current state of the repository but preserved the history and appended 
a new commit.

Unstaging Files
What happens if we make some changes to a file and git add them but decide we are not yet ready to commit.
 We can unstage these commits in (at least) on of two ways. First let's add a new line:

% nano mars.txt
% cat mars.txt
Cold and dry, but everything is my favorite color
The two moons may be a problem for Wolfman
But the Mummy will appreciate the lack of humidity
An unyet sure change
and stage the change:

% git add mars.txt
% git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        modified:   mars.txt
Fortunately git has given us a suggestion as to how we can unstage these changes "git reset HEAD <file>...". 
Let's see what happens if we do this:

% git reset HEAD mars.txt
% git status
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   mars.txt

no changes added to commit (use "git add" and/or "git commit -a")
% cat mars.txt
Cold and dry, but everything is my favorite color
The two moons may be a problem for Wolfman
But the Mummy will appreciate the lack of humidity
An unyet sure change
The file has been unstaged but the changes we made to the file have been preserved. We don't want to keep this 
change so we checkout the previous version of the file with:

% git checkout HEAD mars.txt
% cat mars.txt
Cold and dry, but everything is my favorite color
The two moons may be a problem for Wolfman
But the Mummy will appreciate the lack of humidity
% git status
On branch master
nothing to commit, working tree clean
Remove staged files from the repository
Finally what if we git add a file by mistake. We need to remove it from the staging area but don't want to
 delete it from the directory. Perhaps we have accidentally added an interim or output file. First lets create 
a new file and add it to the the repository:

% touch phobos.txt
% git add phobos.txt
% git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        new file:   phobos.txt
What happens if we try to git rm the file:

git rm phobos.txt
error: the following file has changes staged in the index:
    phobos.txt
(use --cached to keep the file, or -f to force removal)
Git won't let us to simply remove the file since the changes have already been staged. Note that once again 
git has prompted us for what we might want to do, indeed it recomments using the --cached flag if we only intend 
to unstafe the file. Let's gie it a try:

% git rm --cached phobos.txt
rm 'phobos.txt'
This looks like the file has been removed but we can check its status with:

% ls
mars.txt  phobos.txt
and:

% git status
On branch master
Untracked files:
  (use "git add <file>..." to include in what will be committed)

        phobos.txt

nothing added to commit but untracked files present (use "git add" to track)
So phobos.txt is no longer being tracked by git but has not been deleted. Actually we decide we don't need this
 empty file apparently there's nothing of interest worthy of recording on phobos so we delete the file. As it is 
not in the git repository we can just use:

% rm phobos.txt
% ls
mars.txt
% git status
On branch master
nothing to commit, working tree clean

 Key Points
-------------------------------------------------
git mv can be used to rename or move files within the repository.
git rm can be used to remove a file from a repository, or with --cached unstage a file
git checkout <commit id> <file> recovers old versions of files.
git checkout <commit id> moves your position in the repository.
git revert can be used to revert the entire repository to a previous state, or undo changes in range of commits, 
creating a new commit.
git reset changes the current HEAD to an earlier commit








Ignoring Things
---------------------------------------------------------------------------------------------------
How can I tell Git to ignore files I don’t want to track?
Objectives

Configure Git to ignore specific files.
Explain why ignoring files can be useful.
What if we have files that we do not want Git to track for us, like backup files created by our editor or 
intermediate files created during data analysis? Let’s create a few dummy files:

% mkdir results
% touch a.dat b.dat c.dat results/a.out results/b.out
and see what Git says:

% git status
On branch master
Untracked files:
  (use "git add <file>..." to include in what will be committed)

    a.dat
    b.dat
    c.dat
    results/
nothing added to commit but untracked files present (use "git add" to track)
Putting these files under version control would be a waste of disk space. What’s worse, having them all listed 
could distract us from changes that actually matter, so let’s tell Git to ignore them.

We do this by creating a file in the root directory of our project called .gitignore:

% nano .gitignore
% cat .gitignore
*.dat
results/
These patterns tell Git to ignore any file whose name ends in .dat and everything in the results directory.
 (If any of these files were already being tracked, Git would continue to track them.)

Once we have created this file, the output of git status is much cleaner:

% git status
On branch master
Untracked files:
  (use "git add <file>..." to include in what will be committed)

    .gitignore
nothing added to commit but untracked files present (use "git add" to track)
The only thing Git notices now is the newly-created .gitignore file. You might think we wouldn’t want to 
track it, but everyone we’re sharing our repository with will probably want to ignore the same things that 
we’re ignoring. Let’s add and commit .gitignore:

% git add .gitignore
% git commit -m "Add the ignore file"
% git status
# On branch master
nothing to commit, working directory clean
As a bonus, using .gitignore helps us avoid accidentally adding to the repository files that we don’t 
want to track:

% git add a.dat
The following paths are ignored by one of your .gitignore files:
a.dat
Use -f if you really want to add them.
If we really want to override our ignore settings, we can use git add -f to force Git to add something. 
For example, git add -f a.dat. We can also always see the status of ignored files if we want:

% git status --ignored
On branch master
Ignored files:
 (use "git add -f <file>..." to include in what will be committed)

        a.dat
        b.dat
        c.dat
        results/

nothing to commit, working directory clean
 Ignoring Nested Files
Given a directory structure that looks like:

resul./data results/plots How would you ignore only results/plots and not resul./data?

Solution

 Including Specific Files
How would you ignore all .data files in your root directory except for final.data? Hint: Find out 
what ! (the exclamation point operator) does.

Solution

 Ignoring all data Files in a Directory
Given a directory structure that looks like:

resul./data/position/gps/a.data
resul./data/position/gps/b.data
resul./data/position/gps/c.data
resul./data/position/gps/info.txt
results/plots
What’s the shortest .gitignore rule you could write to ignore all .data files in resu./data/position/gps? 
Do not ignore the info.txt.

Solution

 Log Files
You wrote a script that creates many intermediate log-files of the form log_01, log_02, log_03, etc. 
You want to keep them but you do not want to track them through git.

Write one .gitignore entry that excludes files of the form log_01, log_02, etc.

You find that the file log_01 is very important after all, add it to the tracked files without changing 
the .gitignore again.

Discuss with your neighbor what other types of files could reside in your directory that you do not want 
to track and thus would exclude via .gitignore.

Solution

 Key Points
The .gitignore file tells Git what files to ignore.







Remotes in GitHub
---------------------------------------------------------------------------------------------------

How do I share my changes with others (on the web)?
Objectives

Explain what remote repositories are and why they are useful.
Push to or pull from a remote repository.
Version control really comes into its own when we begin to collaborate with other people. We already have most 
of the machinery we need to do this; the only thing missing is to copy changes from one repository to another.

Systems like Git allow us to move work between any two repositories. In practice, though, it’s easiest to use 
one copy as a central hub, and to keep it on the web rather than on someone’s laptop. Most programmers use hosting 
services like GitHub, BitBucket or GitLab to hold those master copies; we’ll explore the pros and cons of this in 
the final section of this lesson.

Let’s start by sharing the changes we’ve made to our current project with the world. Log in to GitHub, then click 
on the icon in the top right corner to create a new repository called planets:

Github create repository

Name your repository planets, add an optional description and the click Create Repository.

Github name and describe repository

As soon as the repository is created, GitHub displays a page with a URL and some information on how to configure 
your local repository:

Github quick start

which effectively does the following on GitHub’s servers:

% mkdir planets
% cd planets
% git init
Our local repository contains our earlier work on mars.txt, but the remote repository on GitHub doesn’t contain 
any files yet:Local and remote repo states

The next step is to connect the two repositories. We do this by making the GitHub repository a remote for the local 
repository. The home page of the repository on GitHub includes the string we need to identify it:Copy repository 
string

Click on the HTTPS link to change the protocol from SSH to HTTPS if needed.

 HTTPS vs. SSH
-------------------------------------------------
We use HTTPS here because it does not require additional configuration. After the workshop you may want to set 
up SSH access, which is a bit more secure, by following one of the great tutorials from GitHub, Atlassian/BitBucket 
and GitLab (this one has a screencast).

Copy that URL from the browser, go into the local planets repository, and run this command:

% git remote add origin https://github.com/vlad/planets.git
Make sure to use the URL for your repository rather than Vlad’s: the only difference should be your username 
instead of vlad.

We can check that the command has worked by running git remote -v:

% git remote -v
origin   https://github.com/vlad/planets.git (push)
origin   https://github.com/vlad/planets.git (fetch)
The name origin is a local nickname for your remote repository. We could use something else if we wanted to, but 
origin is by far the most common choice.

Once the nickname origin is set up, this command will push the changes from our local repository to the repository
 on GitHub:

% git push origin master
Counting objects: 9, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (9/9), 821 bytes, done.
Total 9 (delta 2), reused 0 (delta 0)
To https://github.com/vlad/planets
 * [new branch]      master -> master
Branch master set up to track remote branch master from origin.
Our local and remote repositories are now in this state:

Remote and local repos after first push

 The -u Flag
You may see a -u option used with git push in some documentation. This option is synonymous with the 
--set-upstream-to option for the git branch command, and is used to associate the current branch with a remote 
branch so that the git pull command can be used without any arguments. To do this, simply use git push -u origin 
master once the remote has been set up.

We can pull changes from the remote repository to the local one as well:

% git pull origin master
From https://github.com/vlad/planets
 * branch            master     -> FETCH_HEAD
Already up-to-date.
Pulling has no effect in this case because the two repositories are already synchronized. If someone else had 
pushed some changes to the repository on GitHub, though, this command would download them to our local repository.

 GitHub GUI
-------------------------------------------------
Browse to your planets repository on GitHub. Under the Code tab, find and click on the text that 
says “XX commits” (where “XX” is some number). Hover over, and click on, the three buttons to the right of each 
commit. What information can you gather/explore from these buttons? How would you get that same information in 
the shell?

Solution
-------------------------------------------------

 GitHub Timestamp
Create a remote repository on GitHub. Push the contents of your local repository to the remote. Make changes to 
your local repository and push these changes. Go to the repo you just created on GitHub and check the timestamps 
of the files. How does GitHub record times, and why?

Solution

 Push vs. Commit
-------------------------------------------------
In this lesson, we introduced the git push command. How is git push different from git commit?

Solution

 Proxy
-------------------------------------------------
If the network you are connected to uses a proxy, there is a chance that your last command failed with “Could not 
resolve hostname” as the error message. To solve this issue, you need to tell Git about the proxy:

% git config --global http.proxy http://user:password@proxy.url
% git config --global https.proxy http://user:password@proxy.url
When you connect to another network that doesn’t use a proxy, you will need to tell Git to disable the proxy using:

% git config --global --unset http.proxy
% git config --global --unset https.proxy
On linux.bath the proxy should be configured to allow you to use git with remote repositories over http so askan 
demonstrator if you have any issues.

 Password Managers
-------------------------------------------------
If your operating system has a password manager configured, git push will try to use it when it needs your username 
and password. For example, this is the default behavior for Git Bash on Windows. If you want to type your username 
and password at the terminal instead of using a password manager, type:

% unset SSH_ASKPASS
in the terminal, before you run git push. Despite the name, git uses SSH_ASKPASS for all credential entry, so you 
may want to unset SSH_ASKPASS whether you are using git via SSH or https.

You may also want to add unset SSH_ASKPASS at the end of your ~/.bashrc to make git default to using the terminal 
for usernames and passwords.

 Key Points
-------------------------------------------------
A local Git repository can be connected to one or more remote repositories.
Use the HTTPS protocol to connect to remote repositories until you have learned how to set up SSH.
git push copies changes from a local repository to a remote repository.
git pull copies changes from a remote repository to a local repository.








Collaborating
---------------------------------------------------------------------------------------------------
How can I use version control to collaborate with other people?
Objectives

Clone a remote repository.
Collaborate pushing to a common repository.
For the next step, get into pairs. One person will be the “Owner” and the other will be the “Collaborator”. 
The goal is that the Collaborator add changes into the Owner’s repository. We will switch roles at the end, 
so both persons will play Owner and Collaborator.

 Practicing By Yourself
If you’re working through this lesson on your own, you can carry on by opening a second terminal window. This 
window will represent your partner, working on another computer. You won’t need to give anyone access on GitHub, 
because both ‘partners’ are you.

The Owner needs to give the Collaborator access. On GitHub, click the settings button on the right, then select 
Collaborators, and enter your partner’s username.

Github add collaborators

To accept access to the Owner’s repo, the Collaborator needs to go to https://github.com/notifications. Once there 
she can accept access to the Owner’s repo.

Next, the Collaborator needs to download a copy of the Owner’s repository to her machine. This is called “cloning a 
repo”. To clone the Owner’s repo into her Desktop folder, the Collaborator enters:

% git clone https://github.com/vlad/planets.git ~/Desktop/vlad-planets
Replace ‘vlad’ with the Owner’s username.

Collaboration

The Collaborator can now make a change in her clone of the Owner’s repository, exactly the same way as we’ve been 
doing before:

% cd ~/Desktop/vlad-planets
% nano pluto.txt
% cat pluto.txt
It is so a planet!
% git add pluto.txt
% git commit -m "Add notes about Pluto"
1 file changed, 1 insertion(+)
 create mode 100644 pluto.txt
Then push the change to the Owner’s repository on GitHub:

% git push origin master
Counting objects: 4, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 306 bytes, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://github.com/vlad/planets.git
   9272da5..29aba7c  master -> master
Note that we didn’t have to create a remote called origin: Git uses this name by default when we clone a 
repository. (This is why origin was a sensible choice earlier when we were setting up remotes by hand.)

Take a look to the Owner’s repository on its GitHub website now (maybe you need to refresh your browser.) 
You should be able to see the new commit made by the Collaborator.

To download the Collaborator’s changes from GitHub, the Owner now enters:

% git pull origin master
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 3 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://github.com/vlad/planets
 * branch            master     -> FETCH_HEAD
Updating 9272da5..29aba7c
Fast-forward
 pluto.txt | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 pluto.txt
Now the three repositories (Owner’s local, Collaborator’s local, and Owner’s on GitHub) are back in sync.

 A Basic Collaborative Workflow
In practice, it is good to be sure that you have an updated version of the repository you are collaborating on, 
so you should git pull before making our changes. The basic collaborative workflow would be:

update your local repo with git pull origin master,
make your changes and stage them with git add,
commit your changes with git commit -m, and
upload the changes to GitHub with git push origin master
It is better to make many commits with smaller changes rather than of one commit with massive changes: small 
commits are easier to read and review.

 Switch Roles and Repeat
Switch roles and repeat the whole process.

 Review Changes
The Owner pushed commits to the repository without giving any information to the Collaborator. How can the 
Collaborator find out what has changed with command line? And on GitHub?

Solution

 Comment Changes in GitHub
The Collaborator has some questions about one line change made by the Owner and has some suggestions to propose.

With GitHub, it is possible to comment the diff of a commit. Over the line of code to comment, a blue comment 
icon appears to open a comment window.

The Collaborator posts its comments and suggestions using GitHub interface.

 Version History, Backup, and Version Control
Some backup software can keep a history of the versions of your files. They also allows you to recover specific 
versions. How is this functionality different from version control? What are some of the benefits of using version
control, Git and GitHub?

 Key Points
git clone copies a remote repository to create a local repository with a remote called origin automatically set up.
git pull updates your local copy of the repository with any changes to the remote.
git fetch fetches changes to the remote allowing you to compare them without merging









Conflicts
---------------------------------------------------------------------------------------------------


What do I do when my changes conflict with someone else’s?
Objectives

Explain what conflicts are and when they can occur.
Resolve conflicts resulting from a merge.
As soon as people can work in parallel, they’ll likely step on each other’s toes. This will even happen with a 
single person: if we are working on a piece of software on both our laptop and a server in the lab, we could make 
different changes to each copy. Version control helps us manage these conflicts by giving us tools to resolve 
overlapping changes.

To see how we can resolve conflicts, we must first create one. The file mars.txt currently looks like this in 
both partners’ copies of our planets repository:

% cat mars.txt
Cold and dry, but everything is my favorite color
The two moons may be a problem for Wolfman
But the Mummy will appreciate the lack of humidity
Let’s add a line to one partner’s copy only:

% nano mars.txt
% cat mars.txt
Cold and dry, but everything is my favorite color
The two moons may be a problem for Wolfman
But the Mummy will appreciate the lack of humidity
This line added to Wolfman's copy
and then push the change to GitHub:

% git add mars.txt
% git commit -m "Add a line in our home copy"
[master 5ae9631] Add a line in our home copy
 1 file changed, 1 insertion(+)
% git push origin master
Counting objects: 5, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 352 bytes, done.
Total 3 (delta 1), reused 0 (delta 0)
To https://github.com/vlad/planets
   29aba7c..dabb4c8  master -> master
Now let’s have the other partner make a different change to their copy without updating from GitHub:

% nano mars.txt
% cat mars.txt
Cold and dry, but everything is my favorite color
The two moons may be a problem for Wolfman
But the Mummy will appreciate the lack of humidity
We added a different line in the other copy
We can commit the change locally:

% git add mars.txt
% git commit -m "Add a line in my copy"
[master 07ebc69] Add a line in my copy
 1 file changed, 1 insertion(+)
but Git won’t let us push it to GitHub:

% git push origin master
To https://github.com/vlad/planets.git
 ! [rejected]        master -> master (non-fast-forward)
error: failed to push some refs to 'https://github.com/vlad/planets.git'
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Merge the remote changes (e.g. 'git pull')
hint: before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
Conflict!

Git detects that the changes made in one copy overlap with those made in the other and stops us from trampling 
on our previous work. What we have to do is pull the changes from GitHub, merge them into the copy we’re currently 
working in, and then push that. Let’s start by pulling:

% git pull origin master
remote: Counting objects: 5, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 1), reused 3 (delta 1)
Unpacking objects: 100% (3/3), done.
From https://github.com/vlad/planets
 * branch            master     -> FETCH_HEAD
Auto-merging mars.txt
CONFLICT (content): Merge conflict in mars.txt
Automatic merge failed; fix conflicts and then commit the result.
git pull tells us there’s a conflict, and marks that conflict in the affected file:

% cat mars.txt
Cold and dry, but everything is my favorite color
The two moons may be a problem for Wolfman
But the Mummy will appreciate the lack of humidity
<<<<<<< HEAD
We added a different line in the other copy
=======
This line added to Wolfman's copy
>>>>>>> dabb4c8c450e8475aee9b14b4383acc99f42af1d
Our change is preceded by <<<<<<< HEAD. Git has then inserted ======= as a separator between the conflicting 
changes and marked the end of the content downloaded from GitHub with >>>>>>>. (The string of letters and digits 
after that marker identifies the commit we’ve just downloaded.)

It is now up to us to edit this file to remove these markers and reconcile the changes. We can do anything we 
want: keep the change made in the local repository, keep the change made in the remote repository, write something 
new to replace both, or get rid of the change entirely. Let’s replace both so that the file looks like this:

% cat mars.txt
Cold and dry, but everything is my favorite color
The two moons may be a problem for Wolfman
But the Mummy will appreciate the lack of humidity
We removed the conflict on this line
To finish merging, we add mars.txt to the changes being made by the merge and then commit:

% git add mars.txt
% git status
On branch master
All conflicts fixed but you are still merging.
  (use "git commit" to conclude merge)

Changes to be committed:

    modified:   mars.txt
% git commit -m "Merge changes from GitHub"
[master 2abf2b1] Merge changes from GitHub
Now we can push our changes to GitHub:
% git push origin master
Counting objects: 10, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 697 bytes, done.
Total 6 (delta 2), reused 0 (delta 0)
To https://github.com/vlad/planets.git
   dabb4c8..2abf2b1  master -> master
Git keeps track of what we’ve merged with what, so we don’t have to fix things by hand again when the 
collaborator who made the first change pulls again:

% git pull origin master
remote: Counting objects: 10, done.
remote: Compressing objects: 100% (4/4), done.
remote: Total 6 (delta 2), reused 6 (delta 2)
Unpacking objects: 100% (6/6), done.
From https://github.com/vlad/planets
 * branch            master     -> FETCH_HEAD
Updating dabb4c8..2abf2b1
Fast-forward
 mars.txt | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
We get the merged file:

% cat mars.txt
Cold and dry, but everything is my favorite color
The two moons may be a problem for Wolfman
But the Mummy will appreciate the lack of humidity
We removed the conflict on this line
We don’t need to merge again because Git knows someone has already done that.

We don’t need to merge again because Git knows someone has already done that.

Git’s ability to resolve conflicts is very useful, but conflict resolution costs time and effort, and can 
introduce errors if conflicts are not resolved correctly. If you find yourself resolving a lot of conflicts in a
 project, consider these technical approaches to reducing them:

Pull from upstream more frequently, especially before starting new work
Use topic branches to segregate work, merging to master when complete
Make smaller more atomic commits
Where logically appropriate, break large files into smaller ones so that it is less likely that two authors 
will alter the same file simultaneously
Conflicts can also be minimized with project management strategies:

Clarify who is responsible for what areas with your collaborators
Discuss what order tasks should be carried out in with your collaborators so that tasks expected to change the 
same lines won’t be worked on simultaneously
If the conflicts are stylistic churn (e.g. tabs vs. spaces), establish a project convention that is governing 
and use code style tools (e.g. htmltidy, perltidy, rubocop, etc.) to enforce, if necessary
 Key Points
Conflicts occur when two or more people change the same file(s) at the same time.
The version control system does not allow people to overwrite each other’s changes blindly, but highlights 
conflicts so that they can be resolved.








Open Science
---------------------------------------------------------------------------------------------------

How can version control help me make my work more open?
Objectives Explain how a version control system can be leveraged as an electronic lab notebook for computational 
work.

The opposite of “open” isn’t “closed”. The opposite of “open” is “broken”.

John Wilbanks

Free sharing of information might be the ideal in science, but the reality is often more complicated. Normal 
practice today looks something like this:

A scientist collects some data and stores it on a machine that is occasionally backed up by her department.
She then writes or modifies a few small programs (which also reside on her machine) to analyze that data.
Once she has some results, she writes them up and submits her paper. She might include her dataa growing number 
of journals require thisbut she probably doesn’t include her code.
Time passes.
The journal sends her reviews written anonymously by a handful of other people in her field. She revises her paper 
to satisfy them, during which time she might also modify the scripts she wrote earlier, and resubmits.
More time passes.
The paper is eventually published. It might include a link to an online copy of her data, but the paper itself will 
be behind a paywall: only people who have personal or institutional access will be able to read it.
For a growing number of scientists, though, the process looks like this:

The data that the scientist collects is stored in an open access repository like figshare or Zenodo, possibly as 
soon as it’s collected, and given its own Digital Object Identifier (DOI). Or the data was already published and 
is stored in Dryad.
The scientist creates a new repository on GitHub to hold her work.
As she does her analysis, she pushes changes to her scripts (and possibly some output files) to that repository. 
She also uses the repository for her paper; that repository is then the hub for collaboration with her colleagues.
When she’s happy with the state of her paper, she posts a version to arXiv or some other preprint server to invite 
feedback from peers.
Based on that feedback, she may post several revisions before finally submitting her paper to a journal.
The published paper includes links to her preprint and to her code and data repositories, which makes it much 
easier for other scientists to use her work as starting point for their own research.
This open model accelerates discovery: the more open work is, the more widely it is cited and re-used. However, 
people who want to work this way need to make some decisions about what exactly “open” means and how to do it. You 
can find more on the different aspects of Open Science in this book.

This is one of the (many) reasons we teach version control. When used diligently, it answers the “how” question by 
acting as a shareable electronic lab notebook for computational work:

The conceptual stages of your work are documented, including who did what and when. Every step is stamped with an 
identifier (the commit ID) that is for most intents and purposes unique.
You can tie documentation of rationale, ideas, and other intellectual work directly to the changes that spring from
 them.
You can refer to what you used in your research to obtain your computational results in a way that is unique and 
recoverable.
With a distributed version control system such as Git, the version control repository is easy to archive for 
perpetuity, and contains the entire history.
 Make Code Citable
Anything that is hosted in a version control repository (data, code, papers, etc.) can be turned into a citable 
object e.g. visit Zenodo or the University Research Data Management pages.

 How Reproducible Is My Work?
Ask one of your labmates to reproduce a result you recently obtained using only what they can find in your papers 
or on the web. Try to do the same for one of their results, then try to do it for a result from a lab you work with.

Solution

 How to Find an Appropriate Data Repository?
Surf the internet for a couple of minutes and check out the data repositories mentioned above: Figshare, Zenodo, 
Dryad. Depending on your field of research, you might find community-recognized repositories that are well-known 
in your field. You might also find useful these data repositories recommended by Nature. Discuss with your neighbor 
which data repository you might want to approach for your current project and explain why.

Solution

 Key Points
Open scientific work is more useful and more highly cited than closed.

